Implementing Shadoff compression, a mild text compression routine.

Input:  "^IncreaseResistanceToColdWith^Byako'sProtection"
Output: "Increase resistance to cold with Byakko's protection"

in the text loading code:
cmp al, 5e
jne 271c9

(taking code from: 2443:580a 3c81 cmp al, 81)
Taking away code to handle 2-byte SJIS



spaceCtrlCode:
	cmp al 5f   ; _
	jnz overlineCtrlCode ; jump to overline handling code
	lodsb    ; load the number of spaces to repeat
	mov cl, al
	inc di
	loop 5811 ; repeat "inc di"
	lodsb       ; load the next actual character

overlineCtrlCode:
	cmp al, 7e   ; overline
	jnz checkFullwidth
	dec edi  (x04f)

checkFullwidth:
	cmp al, 82
	jne skipCompressionCtrlCode
	mov ah, al
	lodsb
	call 56ed  ; what is this function??
	jmp resumeOriginalProgramming

skipCompressionCtrlCode:
	cmp al, 5e       ; ^ = "skip the compression" code
	jnz ascii   ; if not 5e, go to the next check
	lodsb     ; if 5e, load the next character
	jz resumeOriginalProgramming  ; skip the compression checks

ascii:
	cmp al, 5a       ; Check if above Z
	jg resumeOriginalProgramming         ; jump to end if yes

	cmp al, 40       ; Check if below A
	jl resumeOriginalProgramming         ; jump to end if yes

	inc edi (0x47)   ; increase cursor
	add al, 20       ; lower the letter

	jmp resumeOriginalProgramming      ; (Don't want kanji stuff happening)

resumeOriginalProgramming:
	(...) ; Stuff at 0x584d

|---spacecode -------------| |-overline-| |--------------------------shadoff-----------------------------|
3c5f 750c ac 88c1 47 e2fd ac 3c7e 7501 4f 3c5e 7505 ac 0f842a00 3c5a 0f8f2400 3c40 0f8c1e00 47 0420 e91800


New additions: Want to do normal things when it's a SJIS fullwidth Latin char (prefix 0x82)
When it begins with 82, it does this:

cmp al, 81
jb 5847
cmp al, a0
jb 5814
->
	mov ah, al
	lodsb
	call 56ed

Seems simple enough. I guess I'd have a single "cmp al, 82; je 5814" kind of call

Does 56ed get called normally?

The rewritten code goes from 0x8c0a-0x8c35 in the file.
In the code, that is from 2443:5804-582f



It is correctly ignoring the lowercase letters, but doing a weird kanji or blank space thing with uppercase.

Probably need to jump at the end.

Now it works; still need to use a ^ control code for real uppercase letters.

Now it's working. Need to figure out a better way to encode space separated capitalized words...


So what is at 2443:56ed that the game wants to call when it gets kanji?
cmp ah, 9f
jbe 56f5
etc

But in the translated version, it's:
dec si
loop 56df
etc...
What's changing here?

Any way I can just spoof what happens to it? How does EAX change?
82c7 -> 2604
8260 -> 4203
8261 -> 4303

Maybe I can just subtract... hm
8260 - 7f1e = 342
8261 - 7f1e = 343

sub ax, 0x7f1e
xchg al, ah
0:  66 2d 1e 7f             sub    ax,0x7f1e
4:  86 e0                   xchg   al,ah

**Replace the call to 56ed with these.**

SPACECODE ISSUES
The game seems to calculate the width of windows and cursor highlights based on the length in bytes, not the cursor position.
	As a result, windows are too small and cursor highlights don't reach across the screen, and the screen isn't refreshed properly.